/*
Copyright (C) 2013-2018 Draios Inc dba Sysdig.

This file is part of sysdig.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

#include "sinsp.h"
#include "sinsp_int.h"
#include "filter.h"
#include "chisel.h"
#include "filterchecks.h"
#include "source_plugin_info.h"
#include "source_plugin.h"

#include "source_plugins/source_dynlib.h"

#include <third-party/tinydir.h>

extern sinsp_filter_check_list g_filterlist;
extern vector<chiseldir_info>* g_plugin_dirs;

///////////////////////////////////////////////////////////////////////////////
// source_plugin filter check implementation
// This class implements a dynamic filter check that acts as a bridge to the
// plugin simplified field extraction implementations
///////////////////////////////////////////////////////////////////////////////
class sinsp_filter_check_plugin : public sinsp_filter_check
{
public:
	enum check_type
	{
		TYPE_CNT = 0,
	};

	sinsp_filter_check_plugin()
	{
		m_info.m_name = "plugin";
		m_info.m_fields = NULL;
		m_info.m_nfields = 0;
		m_info.m_flags = filter_check_info::FL_NONE;
		m_cnt = 0;
	}

	int32_t parse_field_name(const char* str, bool alloc_state, bool needed_for_filtering)
	{
		int32_t res = sinsp_filter_check::parse_field_name(str, alloc_state, needed_for_filtering);

		if(res != -1)
		{
			string val(str);
			size_t pos1 = val.find_first_of('[', 0);
			if(pos1 != string::npos)
			{
				size_t argstart = pos1 + 1;
				if(argstart < val.size())
				{
					m_argstr = val.substr(argstart);
					size_t pos2 = m_argstr.find_first_of(']', 0);
					m_argstr = m_argstr.substr(0, pos2);
					m_arg = (char*)m_argstr.c_str();
					return pos1 + pos2 + 2;
				}
			}
		}

		return res;
	}

	sinsp_filter_check* allocate_new()
	{
		sinsp_filter_check_plugin* np = new sinsp_filter_check_plugin();
		np->set_fields((filtercheck_field_info*)m_info.m_fields, m_info.m_nfields);
		np->set_name(m_info.m_name);
		np->m_id = m_id;
		np->m_source_info = m_source_info;

		return (sinsp_filter_check*)np;
	}

	uint8_t* extract(sinsp_evt *evt, OUT uint32_t* len, bool sanitize_strings)
	{
		//
		// Reject any event that is not generated by a plugin
		//
		if(evt->get_type() != PPME_PLUGINEVENT_E)
		{
			return NULL;
		}

		//
		// Reject events that have not generated by this plugin specifically
		//
		sinsp_evt_param *parinfo = evt->get_param(0);
		ASSERT(parinfo->m_len == sizeof(int32_t));
		uint32_t pgid = *(int32_t *)parinfo->m_val;
		if(pgid != m_id)
		{
			return NULL;
		}

		parinfo = evt->get_param(1);
		*len = 0;

		ppm_param_type type = m_info.m_fields[m_field_id].m_type;
		switch(type)
		{
		case PT_CHARBUF:
		{
			char* pret = m_source_info->extract_as_string(evt->get_num(), 
				m_field_id, m_arg, 
				(uint8_t*)parinfo->m_val, 
				parinfo->m_len);
			//if(pret == NULL)
			//{
			//	throw sinsp_exception("plugin's extract_as_string returned a NULL result");
			//}
			if(pret != NULL)
			{
				*len = strlen(pret);
			}
			else
			{
				*len = 0;
			}
			return (uint8_t*)pret;
		}
		default:
			ASSERT(false);
			throw sinsp_exception("plugin extract error unsupported field type " + to_string(type));
			break;
		}

		return NULL;
	}

	void set_name(string name)
	{
		m_info.m_name = name;
	}

	void set_fields(filtercheck_field_info* fields, uint32_t nfields)
	{
		m_info.m_fields = fields;
		m_info.m_nfields = nfields;
	}

	uint64_t m_cnt;
	uint32_t m_id;
	string m_argstr;
	char* m_arg = NULL;
	source_plugin_info* m_source_info;
};

///////////////////////////////////////////////////////////////////////////////
// sinsp_source_plugin implementation
///////////////////////////////////////////////////////////////////////////////
sinsp_source_plugin::sinsp_source_plugin(sinsp* inspector)
{
	m_inspector = inspector;
}

sinsp_source_plugin::~sinsp_source_plugin()
{
	if(m_source_info.destroy != NULL)
	{
		m_source_info.destroy(m_source_info.state);
	}

	if(m_filtercheck)
	{
		delete m_filtercheck;
	}
}

void sinsp_source_plugin::configure(source_plugin_info* plugin_info, char* config)
{
	int init_res;

	ASSERT(m_inspector != NULL);
	ASSERT(plugin_info != NULL);

	m_source_info = *plugin_info;

	if(m_source_info.get_last_error == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'get_last_error' method missing");
	}

	if(m_source_info.get_id == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'get_id' method missing");
	}

	if(m_source_info.open == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'open' method missing");
	}

	if(m_source_info.close == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'close' method missing");
	}

	if(m_source_info.next == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'next' method missing");
	}

	if(m_source_info.event_to_string == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'event_to_string' method missing");
	}

	if(m_source_info.get_name == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'get_name' method missing");
	}

	if(m_source_info.get_fields == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'get_name' method missing");
	}

	if(m_source_info.extract_as_string == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'extract_as_string' method missing");
	}

	if(m_source_info.get_description == NULL)
	{
		throw sinsp_exception("invalid source plugin: 'get_description' method missing");
	}

	//
	// Initialize the plugin
	//
	if(m_source_info.init != NULL)
	{
		m_source_info.state = m_source_info.init(config, &init_res);
		if(init_res != SCAP_SUCCESS)
		{
			throw sinsp_exception(m_source_info.get_last_error());
		}
	}

	m_id = m_source_info.get_id();
	m_source_info.id = m_id;

	//
	// Get JSON with the fields exported by the plugin, parse it and created our
	// list of fields.
	//
	char* sfields = m_source_info.get_fields();
	if(sfields == NULL)
	{
		throw sinsp_exception(string("error in plugin ") + m_source_info.get_name() + ": get_fields returned a null string");
	}
	string json(sfields);
	SINSP_DEBUG("Parsing Container JSON=%s", json.c_str());
	Json::Value root;
	if(Json::Reader().parse(json, root) == false)
	{
		throw sinsp_exception(string("error in plugin ") + m_source_info.get_name() + ": get_fields returned an invalid JSON");
	}

	for(Json::Value::ArrayIndex j = 0; j < root.size(); j++)
	{
		filtercheck_field_info tf;
		tf.m_flags = EPF_NONE;

		const Json::Value &jvtype = root[j]["type"];
		string ftype = jvtype.asString();
		if(ftype == "")
		{
			throw sinsp_exception(string("error in plugin ") + m_source_info.get_name() + ": field JSON entry has no type");
		}
		const Json::Value &jvname = root[j]["name"];
		string fname = jvname.asString();
		if(fname == "")
		{
			throw sinsp_exception(string("error in plugin ") + m_source_info.get_name() + ": field JSON entry has no name");
		}
		const Json::Value &jvdesc = root[j]["desc"];
		string fdesc = jvdesc.asString();
		if(fdesc == "")
		{
			throw sinsp_exception(string("error in plugin ") + m_source_info.get_name() + ": field JSON entry has no desc");
		}

		strncpy(tf.m_name, fname.c_str(), sizeof(tf.m_name));
		strncpy(tf.m_description, fdesc.c_str(), sizeof(tf.m_description));
		tf.m_print_format = PF_DEC;
		if(ftype == "string")
		{
			tf.m_type = PT_CHARBUF;
		}
		else if(ftype == "integer")
		{
			tf.m_type = PT_INT64;
		}
		else if(ftype == "float")
		{
			tf.m_type = PT_DOUBLE;
		}
		else
		{
			throw sinsp_exception(string("error in plugin ") + m_source_info.get_name() + ": invalid field type " + ftype);
		}

		m_fields.push_back(tf);
	}

	m_filtercheck = new sinsp_filter_check_plugin();
	m_filtercheck->set_name(string("plugin_") + m_source_info.get_name());
	m_filtercheck->set_fields((filtercheck_field_info*)&m_fields[0], 
		m_fields.size());
	m_filtercheck->m_id = m_id;
	m_filtercheck->m_source_info = &m_source_info;

	g_filterlist.add_filter_check(m_filtercheck);
}

uint32_t sinsp_source_plugin::get_id()
{
	return m_id;
}

void sinsp_source_plugin::add_plugin_dirs(sinsp* inspector, string sysdig_installation_dir)
{
	//
	// Add the default chisel directory statically configured by the build system
	//
	inspector->add_plugin_dir(sysdig_installation_dir + PLUGINS_INSTALLATION_DIR, false);

	//
	// Add the directories configured in the SYSDIG_PLUGIN_DIR environment variable
	//
	char* s_user_cdirs = getenv("SYSDIG_PLUGIN_DIR");

	if(s_user_cdirs != NULL)
	{
		vector<string> user_cdirs = sinsp_split(s_user_cdirs, ';');

		for(uint32_t j = 0; j < user_cdirs.size(); j++)
		{
			inspector->add_plugin_dir(user_cdirs[j], true);
		}
	}
}

//
// 1. Iterates through the plugin files on disk
// 2. Opens them and add them to the inspector
//
void sinsp_source_plugin::load_dynlib_plugins(sinsp* inspector)
{
	for(vector<chiseldir_info>::const_iterator it = g_plugin_dirs->begin();
		it != g_plugin_dirs->end(); ++it)
	{
		if(string(it->m_dir).empty())
		{
			continue;
		}

		tinydir_dir dir = {};

		tinydir_open(&dir, it->m_dir.c_str());

		while(dir.has_next)
		{
			tinydir_file file;
			tinydir_readfile(&dir, &file);

			string fname(file.name);
			string fpath(file.path);
			bool add_to_vector = false;
			source_plugin_info si;
			string error;

			if(fname == "." || fname == "..")
			{
				goto nextfile;
			}

			if(create_dynlib_source(file.path, &si, &error) == false)
			{
				fprintf(stderr, "cannot load plugin %s : %s", file.path, error.c_str());
				goto nextfile;
			}

			inspector->add_source_plugin(&si, NULL);

nextfile:
			tinydir_next(&dir);
		}

		tinydir_close(&dir);
	}
}

void sinsp_source_plugin::register_source_plugins(sinsp* inspector, string sysdig_installation_dir)
{
	add_plugin_dirs(inspector, sysdig_installation_dir);
	load_dynlib_plugins(inspector);

	//
	// ADD INTERNAL SOURCE PLUGINS HERE
	//
//	source_plugin_info src_plugin = create_dynlib_source(DYNLIB_NAME);
//	inspector->add_source_plugin(&src_plugin, NULL);
}
